#
#                Ce fichier : Core Code modèle ADEL(cinetique, ssi...) sous R
#
#                Doc input et exemples sont dans docAdel.R
#
#                macros Parametrisation et visu parametres sont dans setAdel.R
#
#                macros pour utilisation R,alea et python sont dans UseAdel.R
#
#
# disparition gaine a faire disp - ssi dd apres sa senescence
#
# accrocher la feuille axilante lors de l'inclinaison
#
# inclinaison talle : fonction a definir (debut a f1) par Mariem et a ajouter
#
#
# Linear interpolator/extrapolator
#
openapprox <- function(x,y,xout,extrapolate=TRUE) {
  xy <- cbind(x,y)
  xy <- xy[order(xy[,1]),]
  res <- approx(xy[,1],xy[,2],xout = xout,rule=2)$y
  last <- nrow(xy)
  twolast <- c(last - 1,last)
  if (extrapolate) {
    lastrate <- diff(xy[twolast,2]) / diff(xy[twolast,1])
    firstrate <- diff(xy[1:2,2]) / diff(xy[1:2,1])
  } else {
    lastrate <- 0
    firstrate <- 0
  }
  extrax <- xout > xy[last,1]
  res[extrax] <- xy[last,2] + lastrate * (xout[extrax] - xy[last,1])
  extrax <- xout < xy[1,1]
  res[extrax] <- xy[1,2] +  firstrate * (xout[extrax] - xy[1,1])
  res
}
#
#proportion Senesced as a function of Relative ssi and number from top
#
psen <- function(rssi,nt,ssisenT) {
  ndelsen <- max(ssisenT$ndel)
  ssisenT <- ssisenT[order(ssisenT$ndel),]
  t1delsen <- ssisenT$dssit1 - ssisenT$ndel
  t2delsen <- ssisenT$dssit2 - ssisenT$ndel
  senrate <- ssisenT$rate
  psen <- ifelse(rssi<=(-1),0,ifelse(rssi >= 1,1,rssi + 1))
  if (nt < ndelsen) {
    t0 <- (nt-ndelsen)
    t1 <- t1delsen[ndelsen-nt]
    t2 <- t2delsen[ndelsen-nt]
    psen <- openapprox(c(t0,t1,t2),c(0,senrate[ndelsen-nt]*(t1-t0),1),rssi,extrapolate=FALSE)
  }
  psen
}
                 
#
# kinL : Model for organ extension and leaf senescence
#
#
# TO DO : voir systeme avec HS "continu", et duree croissance leaf = 2 phyllos, et fin croissance = ligulation => Tip ne sera plus utilise
#
#
# Pb 2 : comme la gaine est sur l'arrondi de fin de croissance, dans le modele elle va trop vite (prolongement de la lineaire) : how to deal with that (concernerait surtout les 3 derniers ) ?
#
#
#plant are the parameters generated by setAdel
#
kinL <- function(x,plant,pars=list("startLeaf" = -0.4, "endLeaf" = 1.6, "stemLeaf" = 1.2)) {
  #Model parameter
  startLeaf <- pars$startLeaf
  endLeaf <- pars$endLeaf
  stemleaf <- pars$stemLeaf
  startE <- endLeaf
  endE <- startE + (endLeaf - startLeaf) / stemleaf
  #setting output
  naxe <- nrow(plant$axeT)
  nf <- plant$axeT$nf
  nx <- length(x)
  res <- vector("list",naxe)
  names(res) <- plant$axeT$axe
  #compute kinetic
  for (a in seq(naxe)) {
    xa <- x
    xend <- plant$axeT$end[a]
    if (!is.na(xend))
      xa[xa>=xend] <- xend
    ph <- openapprox(plant$pheno[[a]]$tip,plant$pheno[[a]]$n,xa)
    ssi <- openapprox(plant$pheno[[a]]$ssi,plant$pheno[[a]]$n,x)
    disp <- openapprox(plant$pheno[[a]]$disp,plant$pheno[[a]]$n,x)
    dim <- data.frame(plant$phytoT[,,a])
    ped <- plant$pedT[[a]]
    kin <- array(NA,c(nx,nf[a]+3,17),list(1:nx,1:(nf[a]+3),c("Ll","Gl","El","Lhem","Lhcol","xh","Lh","ht","Llvis","Glvis","Elvis","Llrolled","Glopen","Llsen","Glsen","Elsen","ntop")))
    for (i in seq(nf[a])) {
      rph <- ph - i
      rssi <- ssi - i
     #longueur blade+sheath
      LGl <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=rph,rule=2)$y
      kin[,i,"Ll"] <- sapply(LGl,function(x) min(x,dim$Ll[i]))
      kin[,i,"Gl"] <- LGl - kin[,i,"Ll"]
      kin[,i,"El"] <- approx(c(startE,endE),c(0,dim$El[i]),xout=rph,rule=2)$y
      # hidden length of metamer at leaf emergence
      Lhem <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=0,rule=2)$y + approx(c(startE,endE),c(0,dim$El[i]),xout=0,rule=2)$y
      # hidden length of metamer at collar appearance
      xcol <- openapprox(plant$pheno[[a]]$n,plant$pheno[[a]]$col,i)
      rphcol <- openapprox(plant$pheno[[a]]$tip,plant$pheno[[a]]$n,xcol) - i
      LGcol <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=rphcol,rule=2)$y
      Lhcol <- LGcol - min(LGcol,dim$Ll[i]) + approx(c(startE,endE),c(0,dim$El[i]),xout=rphcol,rule=2)$y
      # relative progress in emergence
      xh <- max(0, min(1, rph / rphcol))
      kin[,i,"Lhem"] <- Lhem
      kin[,i,"Lhcol"] <-  Lhcol
      kin[,i,"xh"] <- xh
      kin[,i,"Lh"] <- ifelse(xh <= 0, sum(kin[,i,c("Ll","Gl","El")]),Lhem + (Lhcol - Lhem) * xh)
      #sene
      kin[,i,"Llsen"] <- psen(rssi,nf[a]-i, plant$ssisenT) * kin[,i,"Ll"]
      kin[,i,"Glsen"] <- psen(rssi - 2,nf[a]-i, plant$ssisenT) * kin[,i,"Gl"]
      ## disparition feuille
      kin[i <= disp,i,c("Ll","Llsen")] <- 0
      kin[i <= (disp-1),i,c("Gl","Glsen")] <- 0
    }
    #ear + peduncle elongation
    nfa <- nf[a]
    for (i in (nfa+1):(nfa+3))
      kin[,i,c("Ll","Gl","Llsen","Glsen")] <- 0
    for (i in (nfa+2):(nfa+3))
      kin[,i,"El"] <- ifelse(ph < (nfa + 1.6),0,dim$El[i])
    if (dim$El[nfa+1] > 0)
      kin[,nfa+1,"El"] <- approx(c(ped$startPed,ped$endPed),c(0,dim$El[nfa+1]),xout=xa,rule=2)$y
    else
      kin[,nfa+1,"El"] = 0
    #senescence of stem + ear + awn + peduncle
    for (i in 1:(nfa+3))
      kin[,i,"Elsen"] <- ifelse(xa < ped$senPed,0,dim$El[i])
    ##disparition axe = longueurs nulles sauf pour entrenoeuds
    if (!is.na(plant$axeT$disp[a]))
      kin[x > plant$axeT$disp[a],,c("Ll","Gl","Llsen","Glsen")] <- 0
    #rang depuis flag leaf
    for (d in seq(along=x))
    kin[d,,"ntop"] <- -(seq(nrow(kin[d,,])) - nfa)
    res[[a]] <- kin
  }
  res
}
#
#compute rolling (to be done)  + visibilty
#
#hauteur du tube forme par les gaines d'un axe, a prtir des cinetiques de longeur.
#ht0 est la cinetique du tube dans lequel emerge la premiere feuille
#hauteur du tube = depuis la base de l'entreneoud, pour chaque phyto
#
htube <- function(kin,ht0) {
  # hauteur base phyto
  stem <- cumsum(kin$El) - kin$El
  hcol <- stem + kin$Gl + kin$El + kin$Llrolled - kin$Glopen
  #ajout ht0,=>parcours hcol de 1 a n-1
  ht <- sapply(seq(along=hcol),function(i) max(c(ht0,hcol)[1:i]))
  pmax(0,ht - stem)
}
#
checktube <- function(kin,ht0=0) {
  #try to accomodate tube length to emergence constrainst using rolling/opening
  n <- max(seq(nrow(kin))[kin$ntop >=0])
  # for first phytomer, try to accomodate for ht0 if first sheath is too short
  if (ht0 > kin$Gl[1] & kin$xh[1] > 0) {
    delta = ht0 - kin$Gl[1]
    kin$Llrolled[1] = min(delta,kin$Ll[1])
  }
  # makes first phyto replace enclosing sheath
  kin$ht[1] <- 0
  kin$ht <- htube(kin,0)
  if (n >=2)
    for (i in 2:n) {
                                        # for emerged collar, ht must be less than Lh
      if (kin$xh[i] >= 1)
        if (kin$ht[i] > kin$Lh[i]) {
          delta <- kin$ht[i] - kin$Lh[i]
          if (kin$Llrolled[i-1] > 0) {
            dl = min(kin$Llrolled[i-1], delta)
            kin$Llrolled[i-1] = kin$Llrolled[i-1] - dl
            delta = delta - dl
          }
          if (delta > 0) {
            dl = min(delta,kin$Gl[i-1])
            kin$Glopen[i-1] <- dl
          }
                                        #update tube
          kin$ht <- htube(kin,0)
        }
    #for emegrning leaves ht must be as close to Lh as possible
      if (kin$xh[i] > 0 & kin$xh[i] < 1) 
        if (abs(kin$ht[i] - kin$Lh[i]) > 0) {
          delta <- kin$Lh[i] - kin$ht[i]
          if (delta > 0) #tube is too short
            kin$Llrolled[i-1] = min(delta,kin$Ll[i-1])
          else
            kin$Glopen[i-1] = min(delta,kin$Gl[i-1])
                                        #update tube
          kin$ht <- htube(kin,0)
        }
    #for non-emerged leaves, Lh must be less than ht
      if (kin$xh[i] <=0)
        if (kin$Lh[i] > kin$ht[i]) {
          delta <- kin$Lh[i] - kin$ht[i]
          kin$Llrolled[i-1] = min(delta,kin$Ll[i-1])
          kin$ht <- htube(kin,0)
        }
    }
  kin
}
#
#Hmax : hauteur max axe si feuille verticale (pour calcul visibilite talles)
#
Hmax <- function(kin) {
  kin <- data.frame(kin)
  max(cumsum(kin$El)+kin$Gl+kin$Ll)
}
#model: kinlist is the output of kinL : all axes computed as ramification emerging from stem (no enclosing sheath). Length of the enclosing sheath is accomodated by rolling first blade if needed.
#
kinLvis <- function(kinlist,pars=NULL) {
  res <- kinlist
  axes <- as.numeric(names(kinlist))
  for (d in seq(dim(kinlist[[1]])[1])) {
    #Haxe <- sapply(kinlist,function(kinaxe) Hmax(kinaxe[d,,]))
    for (a in seq(kinlist)) {
      kin <- data.frame(kinlist[[a]][d,,])
      #initialisation of rolling/opening
      kin[,c("Llrolled","Glopen")] <- 0
    # calcul visibilite : talles doivent emerger du tube de la gaine axilante
      if (axes[a] == 0) {
        kin$ht <- htube(kin,0)
        kin <- checktube(kin,0)
        htbm <- kin$ht
      } else {
        axil <- htbm[axes[a] + 1]# tiller a emerges from same tube as leaf a+1 on the bearing axe
        kin$ht <- htube(kin,axil)
        kin <- checktube(kin,axil)
      }
                                        #calcul Lvis
      res[[a]][d,,"ht"] <- kin$ht
      res[[a]][d,,"Llrolled"] <- kin$Llrolled
      res[[a]][d,,"Glopen"] <- kin$Glopen      
      res[[a]][d,,"Llvis"] <- pmin(pmax(0,kin$Ll + kin$Gl + kin$El - kin$ht),kin$Ll)
      res[[a]][d,,"Glvis"] <- pmin(pmax(0,kin$Gl + kin$El - kin$ht),kin$Gl)
      res[[a]][d,,"Elvis"] <- pmin(pmax(0,kin$El - kin$ht),kin$El)
#      res[[a]][d,,"Llsen"] <- pmin(res[[a]][d,,"Ll"],kin$Llsen)
#      res[[a]][d,,"Glsen"] <- pmin(res[[a]][d,,"Gl"],kin$Glsen)
#      res[[a]][d,,"Elsen"] <- pmin(res[[a]][d,,"El"],kin$Elsen)
    }
  }
       res
}
#
# Converting kinetics -> Canopy desc table
#
#TO DO : include rolled blade as stem elements
#take into account Llrolled and Glopen
#
#generate desc table(s) for one plant at time t
# stem inclination is beared by visible sheaths (option 0) or by nodes (option 1)
# leaf inclination indicates whether leaf base angle is dynamic or not
#
#
#returns stack of visible elements of the stem of an axe
stemElements <- function(desc) {
  metamer <- NULL
  elt <- NULL
  dl <- NULL
  for (i in seq(nrow(desc))) {
    if (desc$Ev[i] > 0) {
      metamer <- c(metamer,i)
      elt <- c(elt,"en")
      dl <- c(dl,desc$Ev[i])
    }
    if (desc$Gv[i] > 0) {
      metamer <- c(metamer,i)
      elt <- c(elt,"ga")
      dl <- c(dl,desc$Gv[i])
    }
  }
  data.frame(metamer=metamer,elt=elt,dl=dl)
}
#
getdesc <- function(kinlist,plantlist,pars=list("senescence_leaf_shrink" = 0.5,"epsillon" = 1e-6, "dynamic_leaf_angle" = TRUE),t=1) {
  epsillon = pars$epsillon
  fshrink = pars$senescence_leaf_shrink
  res <- NULL
  for (p in seq(kinlist)) {
    #print(p)
    refp <- as.numeric(names(kinlist)[p])
    kin <- kinlist[[p]]
    plant <- plantlist[[p]]
    pldesc <- NULL
    
    for (a in seq(kin)) {
      #print(paste("axe",a))
      axename <- names(kin)[a]
      numaxe <- as.numeric(axename)
      dat <- data.frame(kin[[a]][t,,c("Ll","Gl","El","Llvis","Glvis","Elvis","Llsen","Glsen","Elsen")])
      if (sum(dat) > epsillon | a == 1) {#do not represent empty tillers (BUT main stems are needed even if empty! )
        colnames(dat) <- c("Ll","Gl","El","Lv","Gv","Ev","Lsen","Gsen","Esen")
                                        #  infos brutes de plant parameters
        datp <- data.frame(plant$phytoT[,,a])
        dataxe <- plant$axeT[a,]
        nbleaf <- dataxe$nf
        nbphy <- nrow(dat)#inclus ear,ped et awn
        datp <- datp[1:nbphy,]
      # Calcul des inclinaisons de tiges
      # 1er phyto = entrenoeud a incT
        Einc <- rep(0,nbphy)
        Ginc <- rep(0,nbphy)
        if (numaxe == 0) {
          incT <- dataxe$incT
        } else {
          en <- which(datp$El > epsillon)
          if (length(en) > 0) {
            firstEn <- min(en)
            incT <- max(3,dataxe$incT * dat$El[firstEn] / datp$El[firstEn])
          } else {
            incT <- 3
          }
        }
        Einc[1] <- incT
      # redressement (if any)
        if (dataxe$dredT > 0 & sum(dat$Ev+dat$Gv) > epsillon) {
          #distance inserton talle -> extremite stemElements
          stem <- stemElements(dat)
          alpha <- (90 - incT) * pi / 180
          hc <- cumsum(stem$dl)
          dc <- hc * cos(alpha)
          #phytomer a redresser
          if (any(dc >= dataxe$dredT)) {
            nd <- min(which(dc >= dataxe$dredT))
            #beta : angle entre l'horizontale et l'element nd pour que son extremite tombe a  dredT
            if (nd > 1) {
              beta <- acos( (dataxe$dredT - dc[nd - 1]) / (hc[nd] - hc[nd - 1]) )
              inc <- -(beta - alpha) / pi * 180
              if (stem$elt[nd] == "en") {
                Einc[stem$metamer[nd]] <- inc
              } else {
                Ginc[stem$metamer[nd]] <- inc
              }
              if (nd < nrow(stem)) {
                inc <- - (pi / 2 - beta) / pi * 180
                if (stem$elt[nd] == "en") {
                  Einc[stem$metamer[nd+1]] <- inc
                } else {
                  Ginc[stem$metamer[nd+1]] <- inc
                } 
              }
            } else {#incT too large
              beta <- acos(dataxe$dredT / hc[1])
              Einc[1] <- (pi / 2 - beta) / pi * 180
              if (nrow(stem) > 1) {
                inc <- -Einc[1]
                if (stem$elt[2] == "en") {
                  Einc[stem$metamer[2]] <- inc
                } else {
                  Ginc[stem$metamer[2]] <- inc
                }
              }
            }
          }
        }           

        #azimuts : Attention new 21 fev 2011 : azimuts en relatif / phytomere precedent !
        Laz <- datp$Azim
        Laz[1] <- dataxe$azT
        
        # control of blade basal inclination (to be moved in kinL?)
        Linc <- ifelse(datp$Ll > 0,dat$Lv / datp$Ll,1)
        # setup of Lindex (for Tino, no more needed) as a function of leaf stage
        #LcType <- plant$geoLeaf$Lindex(as.numeric(axename),seq(nbphy),nbleaf - seq(nbphy),dat$Lv/datp$Ll)
        #LcType <- plant$geoLeaf$Lindex(as.numeric(axename),seq(nbphy),nbleaf - seq(nbphy))
      #Epo
        Epo <- c(rep(1,nbleaf),3,3,3)
        Epos <- c(rep(2,nbleaf),4,4,4)
        pogreen <- rep(1,nbphy)
        posen <- rep(2,nbphy)
      #
        pldesc <- rbind(pldesc,
                        cbind(data.frame(refplant_id = rep(refp,nbphy),
                                         axe_id = rep(a,nbphy),
                                         axe=rep(as.numeric(axename),nbphy),
                                         numphy=1:nbphy,
                                         L_shape=datp$Ll,
                                         Lw_shape=datp$Lw,
                                         LsenShrink = fshrink,
                                         LcType=datp$Lindex,
                                         LcIndex=datp$Lseed,
                                         Linc=Linc,
                                         Laz=Laz,
                                         Lpo=pogreen,
                                         Lpos=posen,
                                         Gd=datp$Gd,
                                         Ginc=Ginc,
                                         Gpo=pogreen,
                                         Gpos=posen,
                                         Ed=datp$Ed,
                                         Einc=Einc,
                                         Epo=Epo,
                                         Epos=Epos),
                              dat))
      }
    }
    if (!is.null(pldesc))
      res <- rbind(res,cbind(plant=p,pldesc))
  }
  
  res
}
#
# Checker for axe dynamics of the plants sampled at dates
#
checkAxeDyn <- function(dates,plants) {
  em <- unlist(sapply(plants,function(p) p$axeT$emf1))
  disp <- unlist(sapply(plants,function(p) p$axeT$disp))
  disp[is.na(disp)] <- max(dates) + 1
  nbaxes <- sapply(dates,function(d) length(em[em <=d]) - length(disp[disp <= d]))
  nbaxes
}
    
    

