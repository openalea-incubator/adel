#
#                Ce fichier : Core Code modèle ADEL(cinetique, ssi...) sous R
#
#                Doc input et exemples sont dans docAdel.R
#
#                macros Parametrisation et visu parametres sont dans setAdel.R
#
#                macros pour utilisation R,alea et python sont dans UseAdel.R
#
#
# disparition gaine a faire disp - ssi dd apres sa senescence
#
# accrocher la feuille axilante lors de l'inclinaison
#
# inclinaison talle : fonction a definir (debut a f1) par Mariem et a ajouter
#
#
# Linear interpolator/extrapolator
#
openapprox <- function(x,y,xout,extrapolate=TRUE) {
  xy <- cbind(x,y)
  xy <- xy[order(xy[,1]),]
  res <- approx(xy[,1],xy[,2],xout = xout,rule=2)$y
  last <- nrow(xy)
  twolast <- c(last - 1,last)
  if (extrapolate) {
    lastrate <- diff(xy[twolast,2]) / diff(xy[twolast,1])
    firstrate <- diff(xy[1:2,2]) / diff(xy[1:2,1])
  } else {
    lastrate <- 0
    firstrate <- 0
  }
  extrax <- xout > xy[last,1]
  res[extrax] <- xy[last,2] + lastrate * (xout[extrax] - xy[last,1])
  extrax <- xout < xy[1,1]
  res[extrax] <- xy[1,2] +  firstrate * (xout[extrax] - xy[1,1])
  res
}
#
#senescence pattern for leaf n on an axe bearing nf leaves
#
# 'old' adel model based on csv ssi2sen table
rssi_patternT <- function(n,nf,ssisenT,hasEar=TRUE) {
  ndelsen <- max(ssisenT$ndel)
  pattern <- list(t=c(-1, 0),p=c(0,1))
  if (hasEar & n > (nf - ndelsen)) {
    idel <- n - (nf - ndelsen)
    t0 <- -idel
    t1 <- t0 + ssisenT$dssit1[idel]
    t2 <-  min(t0 + ssisenT$dssit2[idel],nf - n)
    if (nf < ndelsen) {
      t0 <- -nf
      t1 <- min(nf - n, max(t1,t0))#nf - n is complete senescence of last leaf
      t2 <- min(nf - n, max(t2,t1))
      }
    p1 <- ssisenT$rate[idel] * (t1 - t0)
    pattern <- list(t=c(t0,t1,t2),p=c(0,p1,1))
  }
  pattern
}
# new model based on r1 and ndel only
#
#ssi table
ssi_table <- function(r1=.1, ndel=3) {
  table <- matrix(0,ncol=ndel,nrow=ndel)
  table[1,] <- c(rep(r1,ndel-1),1-(ndel-1)*r1)
  for (i in 2:ndel) {
    if ((ndel-i) >= 1)
      table[i,1:(ndel-i)] <- r1
    table[i,ndel-i+2] <- 1 - sum(table[1:(i-1),(ndel-i+2)])
    table[i,ndel-i+1] <- 1 - sum(table[i,])
  }
  table
}
#
rssi_pattern <- function(n,nf,hasEar=TRUE,pars=list(r1=0.07,ndelsen=3)) {
  pattern <- list(t=c(-1, 0),p=c(0,1))
  ndel <- min(pars$ndelsen,nf)
  if (ndel > 1 & hasEar & (nf - n) < pars$ndel) {
    table <- ssi_table(r1=pars$r1,ndel=ndel)
    t <- ((nf - ndel):nf) - n
    p <- cumsum(c(0,table[nf - n + 1,]))
    pattern <- list(t=t,p=p)
  }
  pattern
}
#
#proportion Senesced as a function of Relative ssi and number from top
#TO DO add nf pour gerer pattern special si nf <4 & hasEar
psen <- function(rssi, n, nf, hasEar=TRUE, pars = NULL) {
  if ('ssisenT' %in% names(pars)) 
    pat <- rssi_patternT(n, nf, pars$ssisenT,hasEar)
  else if ('ssipars' %in% names(pars))
    pat <- rssi_pattern(n,nf,hasEar,pars$ssipars)
  else
    pat <- rssi_pattern(n,nf,hasEar)
  openapprox(pat$t, pat$p, rssi, extrapolate=FALSE)
}
                 
#
# kinL : Model for organ extension and leaf senescence
#
#
# TO DO : voir systeme avec HS "continu", et duree croissance leaf = 2 phyllos, et fin croissance = ligulation => Tip ne sera plus utilise
#
#
# Pb 2 : comme la gaine est sur l'arrondi de fin de croissance, dans le modele elle va trop vite (prolongement de la lineaire) : how to deal with that (concernerait surtout les 3 derniers ) ?
#
#
#plant are the parameters generated by setAdel
#
kinL <- function(x,plant,pars=list("leafDuration" = 2, "fracLeaf" = 0.2, "stemDuration" = 2 / 1.2, "dHS_col"=0.2, "dHS_en"=0.)) {
  #Model parameter
  apparentLeafDuration <- (1 - pars$fracLeaf) * pars$leafDuration
  dhslin <-  apparentLeafDuration - pars$dHS_col# delay tip-hslin
  startLeaf <- apparentLeafDuration - pars$leafDuration
  endLeaf <- apparentLeafDuration
  endLeaf1 <- apparentLeafDuration
  startE <- endLeaf + pars$dHS_en
  endE <- startE + pars$stemDuration
  #setting output
  naxe <- nrow(plant$axeT)
  nf <- plant$axeT$nf
  hsf <- plant$axe$HS_final
  nx <- length(x)
  res <- vector("list",naxe)
  names(res) <- plant$axeT$axe
  #compute kinetic
  for (a in seq(naxe)) {
    xa <- x
    xend <- plant$axeT$end[a]
    if (!is.na(xend))
      xa[xa>=xend] <- xend
    ph <- openapprox(plant$pheno[[a]]$tip,plant$pheno[[a]]$n,xa)
    hs <- ph - dhslin
    phcol <- openapprox(plant$pheno[[a]]$col,plant$pheno[[a]]$n,xa)
    ssi <- openapprox(plant$pheno[[a]]$ssi,plant$pheno[[a]]$n,x)
    disp <- openapprox(plant$pheno[[a]]$disp,plant$pheno[[a]]$n,x)
    dim <- data.frame(plant$phytoT[,,a])
    ped <- plant$pedT[[a]]
    kin <- array(NA,c(nx,nf[a]+3,24),list(1:nx,1:(nf[a]+3),c("Ll","Gl","El","Lhem","Lhcol","xh","Lh","ht","Llvis","Glvis","Elvis","Llrolled","Glopen","Llsen","Glsen","Elsen","ntop", "rph", "rssi", "rhs","exposition","lifetime", "age",'is_ligulated')))
    nfa <- nf[a]
    for (i in 1:(nfa+3))
      kin[,i,c("Ll","Gl","El","Llsen","Glsen","Elsen","Llvis")] <- 0
    for (i in seq(nf[a])) {
      #print(i)
      rph <- ph - i
      rssi <- ssi - i
      kin[,i,"rph"] <- rph
      kin[,i,"rssi"] <- rssi
      kin[,i,"rhs"] <- hs - i
      xtip <- openapprox(plant$pheno[[a]]$n,plant$pheno[[a]]$tip,i)
      xssi <- openapprox(plant$pheno[[a]]$n,plant$pheno[[a]]$ssi,i)
      kin[,i,"lifetime"] <- max(0,min(1, (x - xtip) / (xssi - xtip)))
      kin[,i,"age"] <- x - xtip
      kin[,i,"is_ligulated"] <- ifelse(rph > apparentLeafDuration, 1, 0)
     #longueur blade+sheath
      LGl <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=rph,rule=2)$y
      if (i ==1)
        LGl <- approx(c(startLeaf,endLeaf1),c(0,dim$Ll[i]+dim$Gl[i]),xout=rph,rule=2)$y
      El <- approx(c(startE,endE),c(0,dim$El[i]),xout=rph,rule=2)$y
      kin[,i,"Ll"] <- sapply(LGl,function(x) min(x,dim$Ll[i]))
      kin[,i,"Gl"] <- LGl - kin[,i,"Ll"]
      kin[,i,"El"] <- El
      # hidden length of metamer at leaf emergence (depends only on coordination rule)
      Lhem <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=0,rule=2)$y + approx(c(startE,endE),c(0,dim$El[i]),xout=0,rule=2)$y
      # hidden length of metamer at collar appearance (hypothesis: collar app = time at which blade is first completly visible)
      xcol <- openapprox(plant$pheno[[a]]$n,plant$pheno[[a]]$col,i)
      rphcol <- openapprox(plant$pheno[[a]]$tip,plant$pheno[[a]]$n,xcol) - i
      LGcol <- approx(c(startLeaf,endLeaf),c(0,dim$Ll[i]+dim$Gl[i]),xout=rphcol,rule=2)$y
      Ecol <- approx(c(startE,endE),c(0,dim$El[i]),xout=rphcol,rule=2)$y
      Lhcol <- LGcol + Ecol - dim$Ll[i]
      xh <- max(0, rph / rphcol)
      Lh <-  ifelse(xh <= 0, sum(kin[,i,c("Ll","Gl","El")]),Lhem + (Lhcol - Lhem) * min(xh, 1))
      # makes first phyto replace enclosing sheath after emergence
      if (i == 1 & xh > 0) {
        Lh <- 0
      } else if (xh > 1) { 
        Lhmat <- dim$Gl[i - 1]
        Lh <- Lhcol + (Lhcol - Lhmat) * (xh - 1)
        Lh <- ifelse(Lhmat < Lhcol, min(Lhmat, Lh), max(Lhmat, Lh))
      }
      #
      kin[,i,"Lhem"] <- Lhem
      kin[,i,"Lhcol"] <-  Lhcol
      kin[,i,"xh"] <- xh
      kin[,i,"Lh"] <- Lh
      # Llvis is forced to be compatible with tip-col rates, Hcol/Glvis will be adjusted
      kin[,i,"Llvis"] <-  max(0,min(dim$Ll[i],LGl + El - Lh))
      if (dim$Ll[i] > 0)
        kin[,i,"exposition"] <- kin[,i,"Llvis"] / dim$Ll[i]
      #senescence
      kin[,i,"Llsen"] <- psen(rssi, i, nf[a], plant$axeT$hasEar[a], plant) * kin[,i,"Ll"]
      kin[,i,"Glsen"] <- psen(rssi - 2, i, nf[a], plant$axeT$hasEar[a], plant) * kin[,i,"Gl"]

      ## disparition feuille
      kin[i <= disp,i,c("Ll","Llsen","Llvis","Lh")] <- 0
      kin[i <= (disp-1),i,c("Gl","Glsen")] <- 0
    }
    #ear + peduncle elongation
    
    if (plant$axeT$hasEar[a]) {
      for (i in (nfa+2):(nfa+3))
        kin[,i,"El"] <- ifelse(ph < (nfa + 1.6),0,dim$El[i])
      if (dim$El[nfa+1] > 0)
        kin[,nfa+1,"El"] <- approx(c(ped$startPed,ped$endPed),c(0,dim$El[nfa+1]),xout=xa,rule=2)$y
      else
        kin[,nfa+1,"El"] = 0
   #senescence of stem + ear + awn + peduncle
    for (i in 1:(nfa+3))
      kin[,i,"Elsen"] <- tryCatch(ifelse(xa < ped$senPed | length(dim$El[i]) <= 0,0,dim$El[i]), error = function(e) {stop(paste('plant:', plant$refp, 'axe', a, 'i', i));e}) 
    }
    ##TO DO disparition axe = longueurs nulles pour tout ce qui est sur des entrenoeuds allonges sauf pour entrenoeuds
    if (!is.na(plant$axeT$disp[a]))
        #kin[x > plant$axeT$disp[a],,c("Ll","Gl","Llsen","Glsen")] <- 0
        kin[x > plant$axeT$disp[a],,c("Ll","Gl","El","Llsen","Glsen","Elsen","Llvis","Lh")] <- 0
    #rang depuis flag leaf
    for (d in seq(along=x))
      kin[d,,"ntop"] <- -(seq(nrow(kin[d,,])) - nfa)
    res[[a]] <- kin
  }
  res
}
#
#compute rolling (to be done)  + visibilty
#
#hauteur du tube forme par les gaines d'un axe, a prtir des cinetiques de longeur.
#ht0 est la cinetique du tube dans lequel emerge la premiere feuille
#hauteur du tube = depuis la base de l'entreneoud, pour chaque phyto
#
htube <- function(kin,ht0) {
  nmax <- max(seq(nrow(kin))[kin$ntop >=0])
  # hauteur base phyto
  stem <- cumsum(kin$El) - kin$El
  hcol <- stem + kin$Gl + kin$El + kin$Llrolled - kin$Glopen
  #ajout ht0,=>parcours hcol de 1 a n-1
  hins <- sapply(seq(along=hcol),function(i) max(c(ht0,hcol)[1:i]))
  Gt <- sapply(seq(along=hcol),function(i) min(nmax,which.max(c(ht0,hcol)[1:i]) - 1))
  ht <- pmax(0,hins - stem)
  data.frame(hins=hins,ht=ht,Gt=Gt)
}
#
basetube <- function(kin,ht0=0) {
  # for first phytomer, try to accomodate for ht0 if first sheath is too short
  if (ht0 > kin$Gl[1] & kin$xh[1] > 0) {
    delta = ht0 - kin$Gl[1]
    kin$Llrolled[1] = min(delta,kin$Ll[1])
  }
  # makes first phyto replace enclosing sheath after emergence
  if (kin$xh[1] > 0) {
    kin$ht[1] <- 0
    kin$ht <- htube(kin,0)
  }
  kin
}
#
checktube <- function(kin,ht0=0) {
  n <- max(seq(nrow(kin))[kin$ntop >=0])
  #try to accomodate tube length to emergence constrainst using rolling/opening
  if (n >=2)
    for (i in 2:n) {
      # for emerged collar, ht must be less than Lh
      if (kin$xh[i] >= 1)
        if (kin$ht[i] > kin$Lh[i]) {
          delta <- kin$ht[i] - kin$Lh[i]
          if (kin$Llrolled[i-1] > 0) {
            dl = min(kin$Llrolled[i-1], delta)
            kin$Llrolled[i-1] = kin$Llrolled[i-1] - dl
            delta = delta - dl
          }
          if (delta > 0) {
            dl = min(delta,kin$Gl[i-1])
            kin$Glopen[i-1] <- dl
          }
          #update tube
          kin$ht <- htube(kin,0)
        }
    #for emegrning leaves ht must be as close to Lh as possible
      if (kin$xh[i] > 0 & kin$xh[i] < 1) 
        if (abs(kin$ht[i] - kin$Lh[i]) > 0) {
          delta <- kin$Lh[i] - kin$ht[i]
          if (delta > 0) #tube is too short
            kin$Llrolled[i-1] = min(delta,kin$Ll[i-1])
          else
            kin$Glopen[i-1] = min(abs(delta),kin$Gl[i-1]+kin$Llrolled[i-1])
          #update tube
          kin$ht <- htube(kin,0)
        }
    #for non-emerged leaves, Lh must be less than ht
      if (kin$xh[i] <=0)
        if (kin$Lh[i] > kin$ht[i]) {
          delta <- kin$Lh[i] - kin$ht[i]
          kin$Llrolled[i-1] = min(delta,kin$Ll[i-1])
          kin$ht <- htube(kin,0)
        }
    }
  kin
}
#
# compute whorl  adjustements needed to make Lh match ht.
#
whorl <- function(kin) {
  do.call('rbind',lapply(split(kin,kin$Gt),function(mat) {
    res <- NULL
    if (mat$Gt[1] > 0) {
      delta <- mean((mat$Lh - mat$ht)[mat$xh > 0],na.rm=TRUE)
      if (!is.na(delta))
        if (abs(delta) > 1e-6)
          res <- data.frame(Gt=mat$Gt[1],delta=delta)
    }
    res
  }))
}
#
#Hmax : hauteur max axe si feuille verticale (pour calcul visibilite talles)
#
Hmax <- function(kin) {
  kin <- data.frame(kin)
  max(cumsum(kin$El)+kin$Gl+kin$Ll)
}
#
# ms_pos : position of axis on main stem from axis_id.returns 0 for ms itself
ms_pos <- function(axeid) {
  idpos <- strsplit(axeid,split=".",fixed=TRUE)[[1]][1]
  if (idpos=="MS")
    pos <- 0
  else
    pos <- as.numeric(strsplit(idpos,split="T")[[1]][2])
  pos
}
#
# Construct whorl, compute rolling and visibility
#
visibility <- function(kin,ht0=0) {
  #initialisation of rolling/opening
  kin[,c("Llrolled","Glopen")] <- 0
  kin[,c('hins','ht','Gt')] <- htube(kin,ht0)
  if (all(c("xh","Lh") %in% colnames(kin))) {
    w <- whorl(kin)
    if (length(w) > 0)
      for (i in seq(nrow(w))) {
        if (w$delta[i] < 0) {
          kin$Glopen[w$Gt[i]] <-  min(kin$Gl[i],-w$delta[i])
        } else {
          kin$Llrolled[w$Gt[i]] <-  min(w$delta[i],kin$Llvis[i])
        }
      }
    kin[,c('hins','ht','Gt')] <- htube(kin,ht0)
  }
  #kin$Llvis <- pmin(pmax(0,kin$Ll + kin$Gl + kin$El - kin$ht),kin$Ll)
  kin$Glvis <- pmin(pmax(0,kin$Gl - kin$Glopen + kin$El - kin$ht),kin$Gl)
  kin$Elvis <- pmin(pmax(0,kin$El - kin$ht),kin$El)
  kin
}
#
#model: kinlist is the output of kinL : all axes computed as ramification emerging from stem (no enclosing sheath). Length of the enclosing sheath is accomodated by rolling first blade if needed.
#
kinLvis <- function(kinlist,pars=NULL) {
  res <- kinlist
  axes <- names(kinlist)
  for (d in seq(dim(kinlist[[1]])[1])) {
    #Haxe <- sapply(kinlist,function(kinaxe) Hmax(kinaxe[d,,]))
    for (a in seq(kinlist)) {
      kin <- data.frame(kinlist[[a]][d,,c("ntop","Ll","Gl","El","Llvis","Lhem","Lhcol","xh","Lh","rph","rssi", "rhs")])
    # calcul visibilite : talles doivent emerger du tube de la gaine axilante
      if (axes[a] == "MS") {
        ht0 = kin$Lh[1]
        kin <- visibility(kin,ht0)
        htbm <- kin$ht
      } else {
        # numero de la gaine axillante sur le bm
        axilrank <- ms_pos(axes[a])
        axil <- htbm[axilrank + 1]# tiller a emerges from same tube as leaf a+1 on the bearing axe
        kin <- visibility(kin,axil)
      }
      res[[a]][d,,"ht"] <- kin$ht
      res[[a]][d,,"Llrolled"] <- kin$Llrolled
      res[[a]][d,,"Glopen"] <- kin$Glopen      
      res[[a]][d,,"Llvis"] <- kin$Llvis
      res[[a]][d,,"Glvis"] <- kin$Glvis
      res[[a]][d,,"Elvis"] <- kin$Elvis
    }
  }
       res
}
#
# Converting kinetics -> Canopy desc table
#
#TO DO : include rolled blade as stem elements
#take into account Llrolled and Glopen
#
#generate desc table(s) for one plant at time t
# stem inclination is beared by visible sheaths (option 0) or by nodes (option 1)
# leaf inclination indicates whether leaf base angle is dynamic or not
#
#
#returns stack of visible elements of the stem of an axe
stemElements <- function(desc) {
  metamer <- NULL
  elt <- NULL
  dl <- NULL
  for (i in seq(nrow(desc))) {
    if (desc$Ev[i] > 0) {
      metamer <- c(metamer,i)
      elt <- c(elt,"en")
      dl <- c(dl,desc$Ev[i])
    }
    if (desc$Gv[i] > 0) {
      metamer <- c(metamer,i)
      elt <- c(elt,"ga")
      dl <- c(dl,desc$Gv[i])
    }
  }
  data.frame(metamer=metamer,elt=elt,dl=dl)
}
#
# Compute inclinations of stem elements
#
axe_inclination <- function(dat, HS, ht, axename, incBase, dredT, start_incT=1, incT_rate=30,epsillon=1e-6) {
  nbphy <- nrow(dat)#inclus ear,ped et awn
      # Calcul des inclinaisons de tiges
      # 1er phyto = entrenoeud a incT
  Einc <- rep(0,nbphy)
  Ginc <- rep(0,nbphy)
  if (axename == "MS") {
    incT <- incBase
  } else {
    if (HS > start_incT) {
      incT <- max(3,min(incBase, incT_rate * (HS - start_incT)))
    } else {
      incT <- 3
    }
  }
  Einc[1] <- incT
  if (axename != "MS" && incT <= 3) { #Do not represent basal part of first metamer for non inclining tillers
    dat$Lv[1] =  min(dat$Ll[1],max(0, dat$Ll[1] + dat$Gl[1] + dat$El[1] -  ht))
    dat$Lr[1] = min(dat$Lv[1],dat$Lr[1])
    dat$Gv[1] =  min(dat$Gl[1],max(0, dat$Gl[1] + dat$El[1] -  ht))
    dat$Ev[1] =  min(dat$El[1],max(0, dat$El[1] -  ht))
  }
                                        # redressement (if any)
  if (dredT > 0 & sum(dat$Ev+dat$Gv) > epsillon) {
          #distance inserton talle -> extremite stemElements
    stem <- stemElements(dat)
    alpha <- (90 - incT) * pi / 180
    hc <- cumsum(stem$dl)
    dc <- hc * cos(alpha)
    #phytomer a redresser
    if (any(dc >= dredT)) {
      nd <- min(which(dc >= dredT))
      #beta : angle entre l'horizontale et l'element nd pour que son extremite tombe a  dredT
      if (nd > 1) {
        beta <- acos( (dredT - dc[nd - 1]) / (hc[nd] - hc[nd - 1]) )
        inc <- -(beta - alpha) / pi * 180
        if (stem$elt[nd] == "en") {
          Einc[stem$metamer[nd]] <- inc
        } else {
          Ginc[stem$metamer[nd]] <- inc
        }
        if (nd < nrow(stem)) {
          inc <- - (pi / 2 - beta) / pi * 180
          if (stem$elt[nd+1] == "en") {
            Einc[stem$metamer[nd+1]] <- inc
          } else {
            Ginc[stem$metamer[nd+1]] <- inc
          } 
        }
      } else {#incT too large
        beta <- acos(dredT / hc[1])
        Einc[1] <- (pi / 2 - beta) / pi * 180
        if (nrow(stem) > 1) {
          inc <- -Einc[1]
          if (stem$elt[2] == "en") {
            Einc[stem$metamer[2]] <- inc
          } else {
            Ginc[stem$metamer[2]] <- inc
          }
        }
      }
    }
  }
  dat$Einc <- Einc
  dat$Ginc <- Ginc
  dat
}
#
getdesc <- function(kinlist,plantlist,pars=list("senescence_leaf_shrink" = 0.5,"epsillon" = 1e-6, "dynamic_leaf_angle" = TRUE, 'HSstart_inclination_tiller' = 1, 'rate_inclination_tiller' = 30, 'drop_empty'=TRUE),t=1) {
  epsillon = pars$epsillon
  fshrink = pars$senescence_leaf_shrink
  start_incT = pars$HSstart_inclination_tiller
  incT_rate = pars$rate_inclination_tiller
  drop_empty = pars$drop_empty
  res <- NULL
  for (p in seq(kinlist)) {
    #print(p)
    refp <- as.numeric(names(kinlist)[p])
    kin <- kinlist[[p]]
    plant <- plantlist[[p]]
    pldesc <- NULL
    
    for (a in seq(kin)) {
      #print(paste("axe",a))
      axename <- names(kin)[a]
      #numaxe <- as.numeric(axename)
      dat <- data.frame(kin[[a]][t,,c("Ll","Gl","El","Llvis","Glvis","Elvis","Llsen","Glsen","Elsen","Llrolled")])
      if (sum(dat) > epsillon | a == 1) {#do not represent empty tillers (BUT main stems are needed even if empty! )
        colnames(dat) <- c("Ll","Gl","El","Lv","Gv","Ev","Lsen","Gsen","Esen","Lr")
                                        #  infos brutes de plant parameters
        datp <- data.frame(plant$phytoT[,,a])
        dataxe <- plant$axeT[a,]       
        nbleaf <- dataxe$nf
        nbphy <- nrow(dat)#inclus ear,ped et awn
        datp <- datp[1:nbphy,]
      # Calcul des inclinaisons de tiges
        HS_axe <- kin[[a]][t,1,"rhs"] + 1
        if (axename =="MS") {
          ht <- 0
        } else {
          axilrank <- ms_pos(axename)
          ht <- kin$MS[t,axilrank+1,"ht"] # length of the tube the axe emerge from
        }
        dat <- axe_inclination(dat, HS_axe, ht, axename, dataxe$incT, dataxe$dredT, start_incT, incT_rate)

        #azimuts : Attention new 21 fev 2011 : azimuts en relatif / phytomere precedent !
        Laz <- datp$Azim
        Laz[1] <- dataxe$azT
        
        # control of blade basal inclination (to be moved in kinL?)
        Linc <- ifelse(datp$Ll > 0,dat$Lv / datp$Ll,1)
        # setup of Lindex (for Tino, no more needed) as a function of leaf stage
        #LcType <- plant$geoLeaf$Lindex(as.numeric(axename),seq(nbphy),nbleaf - seq(nbphy),dat$Lv/datp$Ll)
        #LcType <- plant$geoLeaf$Lindex(as.numeric(axename),seq(nbphy),nbleaf - seq(nbphy))
      #Epo
        Epo <- c(rep(1,nbleaf),3,3,3)
        Epos <- c(rep(2,nbleaf),4,4,4)
        pogreen <- rep(1,nbphy)
        posen <- rep(2,nbphy)
        rph <- kin[[a]][t,,"rph"]
        rssi <- kin[[a]][t,,"rssi"]
        rhs <- kin[[a]][t,,"rhs"]
        exposition <- kin[[a]][t,,"exposition"]
        lifetime <-  kin[[a]][t,,"lifetime"]
        age <-  kin[[a]][t,,"age"]
        is_ligulated <-  kin[[a]][t,,"is_ligulated"]
        mtype <- c(rep('vegetative',nbleaf),'peduncle','ear','awn')
      #
        pldesc <- rbind(pldesc,
                        cbind(data.frame(refplant_id = rep(refp,nbphy),
                                         axe_id = rep(axename,nbphy),
                                         ms_insertion=rep(ms_pos(axename),nbphy),
                                         az_insertion = rep(dataxe$azTb,nbphy),
                                         nff = dataxe$nf,
                                         nff_end = dataxe$nf_end,
                                         HS_final= dataxe$HS_final,
                                         hasEar = dataxe$hasEar,
                                         numphy=1:nbphy,
                                         ntop= dataxe$nf + 1 - (1:nbphy),
                                         L_shape=datp$Ll,
                                         Lw_shape=datp$Lw,
                                         LsenShrink = rep(fshrink,nbphy),
                                         LcType=datp$Lindex,
                                         LcIndex=datp$Lseed,
                                         Linc=Linc,
                                         Laz=Laz,
                                         Lpo=pogreen,
                                         Lpos=posen,
                                         Gd=datp$Gd,
                                         Ginc=dat$Ginc,
                                         Gpo=pogreen,
                                         Gpos=posen,
                                         Ed=datp$Ed,
                                         Einc=dat$Einc,
                                         Epo=Epo,
                                         Epos=Epos,
                                         rph=rph,
                                         rssi=rssi,
                                         rhs=rhs,
                                         exposition=exposition,
                                         lifetime=lifetime,
	                                 m_type=mtype,
                                         age=age,
                                         is_ligulated = is_ligulated
),
                              dat))
      }
    }
    if (!is.null(pldesc)) {
      if (drop_empty) {
      # option allows filtering non growing metamers,
        ms <- pldesc[pldesc$axe_id =='MS',]
        tillers <- pldesc[pldesc$axe_id !='MS',]
      #keep at least two row of MS to avoid degenerated one-line dataframe in python
        lmetamer <- apply(na.omit(ms[,c('Ll','El','Gl')]),1,sum)
        last <- 1
        if (sum(lmetamer) > 0)
          last <- max(which(lmetamer > 0))
        pldesc <- ms[1:max(2,last),]
        if (nrow(tillers) > 0) {
          tillers <- do.call('rbind',lapply(split(tillers,tillers$axe_id, drop=TRUE), function(axdesc) {
            lmetamer <- apply(na.omit(axdesc[,c('Ll','El','Gl')]),1,sum)
            last <- 1
            if (sum(lmetamer) > 0)
              last <- max(which(lmetamer > 0))
            axdesc[1:last,]
          }))
          pldesc <- rbind(pldesc,tillers)
        }
      }
      res <- rbind(res,cbind(plant=p,pldesc))
    }
  }
  res
}
#
# Checker for axe dynamics of the plants sampled at dates
#
checkAxeDyn <- function(dates,plants, density=1) {
  em <- unlist(sapply(plants,function(p) p$axeT$emf1))
  end <- unlist(sapply(plants,function(p) p$axeT$end))
  disp <- unlist(sapply(plants,function(p) p$axeT$disp))
  em_p <- unlist(sapply(plants,function(p) p$axeT$emf1[p$axeT$axe=='MS']))
  disp_p <- unlist(sapply(plants,function(p) p$axeT$disp[p$axeT$axe=='MS']))
  disp[is.na(disp)] <- max(dates) + 1
  end[is.na(end)] <- max(dates) + 1
  disp_p[is.na(disp_p)] <- max(dates) + 1
  emited <- sapply(dates,function(d) length(em[em <=d]))
  stoped <- sapply(dates,function(d) length(end[end <=d]))
  disped <- sapply(dates,function(d) length(disp[disp <=d]))
  emited_p <- sapply(dates,function(d) length(em_p[em_p<=d]))
  disped_p <- sapply(dates,function(d) length(disp_p[disp_p<=d]))
  nbaxes <- emited
  nbaxes_growing <- emited - stoped
  nbaxes_present <- emited - disped
  nbpl <- emited_p - disped_p
  nbpld <- length(plants)
  data.frame(TT=dates, nbplants=nbpl/nbpld*density, nbaxes_emited=nbaxes/nbpld*density, nbaxes_growing=nbaxes_growing/nbpld*density, nbaxes_present=nbaxes_present/nbpld*density)
}
#
getAxeT <- function(plants) do.call('rbind', mapply(function(idpl,pl) {df=pl$axeT;df$plant=idpl;df},seq(plants),plants,SIMPLIFY=FALSE))
#
getPhenT <- function(plants, axe='MS') do.call('rbind', mapply(function(idpl,pl) {df=pl$pheno[[axe]];df$plant=idpl;df},seq(plants),plants,SIMPLIFY=FALSE))
#
getPhytoT <- function(plants, axe='MS') do.call('rbind', mapply(function(idpl,pl) {df=data.frame(pl$phytoT[,,axe]);df$plant=idpl;df$axe=axe;df$n=seq(nrow(df));df},seq(plants),plants,SIMPLIFY=FALSE))
    

