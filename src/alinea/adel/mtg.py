# -*- coding: utf-8 -*-

"""
Methods on the mtg for adel programs.
Author: Christophe Pradal
License: CeCILL
Date: 08/07/2008
"""

import csv

from openalea.mtg import MTG, fat_mtg

try:
    from openalea.mtg.traversal import *
except:
    pass

# from openalea.mtg.io import read_lsystem_string
from openalea.mtg.algo import union

import numpy
try:
    from openalea.plantgl.all import (Scene, Translation, Vector3, Geometry,
                                      AxisRotation, AxisRotated, Transform4,
                                      BaseOrientation, Shape, Material, Color3,
                                      PglTurtle, Mesh, Translated)
except:
    Material = tuple
    Color3 = tuple
    pass
import random
from math import pi

# import read_lsystem string & deps from newmtg/io
try:
    from openalea.core.logger import get_logger, logging

    logger = get_logger('openalea.mtg')
    _ch = logging.StreamHandler()
    logger.addHandler(_ch)
except:
    logger = None

debug = 0


def log(*args):
    if debug:
        if logger:
            logger.debug('  '.join(map(str, args)))
        else:
            print('  '.join(map(str, args)))


import re


def get_expr(s, expr):
    res = re.search(expr, s)
    _str = ''
    if res:
        _str = s[res.start():res.end()]
    return _str


def get_label(s):
    name = r'[a-zA-Z0-9]+'
    return get_expr(s, name)


def get_name(s):
    name = r'[a-zA-Z]+'
    return get_expr(s, name)


def get_index(s):
    name = r'[0-9]+'
    return get_expr(s, name)


def get_args(s):
    args = r'\([0-9,-\.\+]+\)'
    return get_expr(s, args)


def get_float(s):
    args = r'[0-9-\+]+'
    num = get_expr(s, args)
    return float(num)


def read_lsystem_string( string,
                         symbol_at_scale,
                         functional_symbol={},
                         mtg=None ):
    """Read a string generated by a lsystem.

    :Parameters:

    - `string`: The lsystem string representing the axial tree.
    - `symbol_at_scale`: A dict containing the scale for each symbol name.

    :Optional parameters:

    - `functional_symbol`: A dict containing a function for specific symbols.
        The args of the function have to be coherent with those in the string.
        The return type of the functions have to be a dictionary of properties: dict(name, value)

    :Return:

        MTG object
    """

    import openalea.plantgl.all as pgl
    s = string

    def transform(turtle, mesh):
        x = turtle.getUp()
        z = turtle.getHeading()

        bo = pgl.BaseOrientation(x, z^x)
        matrix = pgl.Transform4(bo.getMatrix())
        matrix.translate(turtle.getPosition())
        mesh = mesh.transform(matrix)
        return mesh
        

    # 1. Create the mtg structure.
    if mtg is None:
        mtg = MTG()

    # 2. add some properties to the MTG
    mtg.add_property('index')
    mtg.add_property('can_label')
    mtg.add_property('geometry')
    mtg.add_property('tissue_type')

    vid = mtg.root # vid of the support tree, i.e. at the finest scale
    current_vertex = mtg.root
    branching_stack = []

    pending_edge = '' # edge type for the next edge to be created
    scale = 0

    lsys_symbols = ['[', ']', '/', '+', '^', 'f']
    modules = symbol_at_scale.keys()
    symbols = lsys_symbols + modules

    index = dict(zip(symbol_at_scale.keys(), [0]*len(symbol_at_scale)))

    is_ramif = False 

    # 2. Create a PlantGL Turtle...
    turtle = pgl.Turtle()

    max_scale = max(symbol_at_scale.values())

    for edge_type in symbols:
        if edge_type != 'f':
            s = s.replace(edge_type, '\n%s'%edge_type)
        else:
            s = s.replace('f(', '\nf(')
    l = s.split()

    try:
        plant_name = [s for s in symbol_at_scale.keys() if 'plant' in s.lower()][0]
    except:
        ValueError("""Incorrect plant name (should be plant)""")

    for node in l:
        # Check if node is a module

        tag = node[0]

        if tag == '[':
            branching_stack.append(vid)
            turtle.push()
            is_ramif = True
        elif tag == ']':
            vid = branching_stack.pop()
            current_vertex = vid
            scale = mtg.scale(vid)
            turtle.pop()
            is_ramif = False
        elif tag == '/':
            args = get_args(node[1:])
            if args:
                angle = get_float(args[1:-1])
                turtle.rollR(angle)
            else:
                turtle.rollR()
        elif tag == '+':
            args = get_args(node[1:])
            if args:
                angle = get_float(args[1:-1])
                turtle.left(angle)
            else:
                turtle.left()
        elif tag == '^':
            args = get_args(node[1:])
            if args:
                angle = get_float(args[1:-1])
                turtle.up(angle)
            else:
                turtle.up()
        elif tag == 'f' and node[1] == '(':
            args = get_args(node[1:])
            if args:
                length = get_float(args[1:-1])
                if length > 0:
                    turtle.f(length)
            else:
                turtle.f()
        else:
            # add new modules to the mtg (i.e. add nodes)
            name = get_name(node)
            if name not in modules:
                print('Unknow element %s' % name)
                continue
            
            module_scale = symbol_at_scale[name]
            if is_ramif:
                edge_type = '+'
            else:
                edge_type = '<'

            log(node, module_scale, edge_type )
            
            if module_scale == scale:
                if mtg.scale(vid) == scale:
                    vid = mtg.add_child(vid, edge_type=edge_type, label=name)
                    current_vertex = vid
                    pending_edge = ''

                    log('','Cas 1.1', scale, 
                        'mtg.scale(vid)', mtg.scale(vid), 
                        'generated vertex', vid)

                    assert mtg.scale(vid) == module_scale
                else:
                    # add the edge to the current vertex
                    current_vertex = mtg.add_child(current_vertex, 
                                                   edge_type=edge_type, 
                                                   label=name)
                    log('', 'Cas 1.2', scale, 
                        'mtg.scale(vid)', mtg.scale(vid), 
                        'generated vertex', current_vertex)
                    assert mtg.scale(current_vertex) == module_scale
                is_ramif = False
            elif module_scale > scale:
                log('', 'Cas 2', scale, 'mtg.scale(vid)', mtg.scale(vid))

                old_current_vertex = current_vertex
                while module_scale > scale:
                    if mtg.scale(vid) == scale:
                        assert vid == current_vertex
                        vid = mtg.add_component(vid)
                        current_vertex = vid
                        log('', '', 'Cas 2.1', scale, 'generate new component', current_vertex)
                        scale += 1
                        if module_scale == scale:
                            assert mtg.scale(current_vertex) == module_scale
                            mtg.property('label')[current_vertex] = name
                            break
                    else:
                        scale += 1
                        current_vertex = mtg.add_component(current_vertex)
                else:
                    log(node, 'add_child(%d, child=%d)'%(old_current_vertex, current_vertex))
                    mtg.property('label')[current_vertex] = name
                    if mtg.scale(vid) == scale:
                        vid = mtg.add_child(vid, child=current_vertex, edge_type=edge_type)
                        is_ramif = False
            else:
                assert module_scale < scale
                while module_scale < scale:
                    scale -= 1
                    current_vertex = mtg.complex(current_vertex)
                else:
                    current_vertex = mtg.add_child(current_vertex, edge_type=edge_type, label=name)
                    assert mtg.scale(current_vertex) == module_scale
        
            # MANAGE the properties, the geometry and the indices!!!
            index[name] += 1
            if name == plant_name:
                for k in index.keys():
                    if k != name:
                        index[k] = 0

            mtg.property('index')[current_vertex] = index[name]
            if name in functional_symbol:
                features = eval(node, functional_symbol)
                geom = features.get('geometry')
                canlabel = features.get('label')
                ttype = features.get('tissue_type')
                
                if geom:
                    # get the transformation from the turtle
                    geom = transform(turtle, geom)
                    mtg.property('geometry')[current_vertex] = geom

                    if name == 'StemElement':
                        # parse args to know how the turtle has to move .
                        args = get_args(node)[1:-1]
                        list_args= args.split(',')
                        length = float(list_args[1]) # 2nd arg
                        if length > 0:
                            turtle.f(length)

                if canlabel:
                    canlabel.elt_id = index[name]
                    plant_id = mtg.complex_at_scale(current_vertex, scale=1)
                    canlabel.plant_id = mtg.property('index')[plant_id]
                    mtg.property('can_label')[current_vertex] = canlabel

                if ttype:
                    mtg.property('tissue_type')[current_vertex] = ttype
                    
    mtg = fat_mtg(mtg)
    return mtg


def to_aggregation_table(g):
    """
    Convert a mtg  `g` to an aggregation table.
    Returns a multi-line string with one line per triangle.
    """

     
    # 1. classe at each scale
    label = g.property('label')
    index = g.property('index')
    geometry = g.property('geometry')
    can_label = g.property("can_label")
    tissue_type = g.property("tissue_type")

    symbols = dict(zip(label.values(), label.keys()))
    for k, v in symbols.items():
        symbols[k] = g.scale(v)

    l = symbols.items()
    l.sort(cmp= lambda x, y: cmp(x[1], y[1]))

    # scales
    header = "Plant Axe Metamer StemElement LeafElement Type"
    header = header.split()

    # 2. iterate on the geometry at the last scale
    assert g.max_scale() == 4

    root_axe = g.roots_iter(scale=2).next()
    root_metamer = g.roots_iter(scale=3).next()
    root_elt = g.roots_iter(scale=4).next()

    # compute the number of triangles

    nb_lines = sum( mesh.indexListSize() for mesh in geometry.values() if mesh)
    lines = numpy.zeros((nb_lines, 6), dtype=int)

    # compute relative index for metamer in axe and element in metamer
    local_index = {}
    #determine the number of element
    nb_stem_elements = {}
    for root_axe in g.roots_iter(scale=2):
        for axe_id in pre_order(g,root_axe):
            for i, mid in enumerate(g.components_iter(axe_id)):
                local_index[mid] = i+1

    for root_metamer in g.roots_iter(scale=3):
        for mid in pre_order(g,root_metamer):
            stem_index = 0
            leaf_index = 0
            for eid in g.components_iter(mid):
                if 'stem' in label[eid].lower():
                    stem_index += 1
                    local_index[eid] = stem_index
                else:
                    leaf_index += 1
                    local_index[eid] = leaf_index
            
            nb_stem_elements[mid] = stem_index

    i = 0
    for root_elt in g.roots_iter(scale=4):
        for vid in pre_order(g, root_elt):
            metamer_id = g.complex(vid)
            axe_id = g.complex(metamer_id)
            plant_id = g.complex(axe_id)

            plant_index = index[plant_id]
            axe_index = index[axe_id]
            metamer_index = local_index[metamer_id]
            element_index = local_index[vid]

            stem_index = 0
            leaf_index = 0

            # element
            is_stem = 'stem' in label[vid].lower()
            if is_stem:
                stem_index = element_index
            else:
                leaf_index = element_index
            #determine tissue type
            ttype = tissue_type[vid]
            
            ##lab = can_label[vid]
##            if lab.is_soil():
##                ttype = 0
##            elif lab.is_leaf():
##                ttype = 1#lamina
##            elif lab.is_stem():
##                if nb_stem_elements[metamer_id] == 1:
##                    ttype = 2 if lab.optical_id <= 2 else 5#2 = sheath, 5 = ear
##                else: 
##                    if element_index == 1:
##                        ttype = 3 if lab.optical_id <= 2 else 4#internode(3) or peduncle(4)
##                    else:
##                        ttype = 2 if lab.optical_id <= 2 else 5#sheath or ear
##            else:
##                ttype = -1 #unknown
            
            

            
            indices = (plant_index, axe_index, metamer_index, stem_index, leaf_index, ttype)
 #           nid  = g.node(vid)
  #          nid.tissue_type = ttype

            geom = geometry.get(vid)
            if geom:
                n = geom.indexListSize()
                for j in range(n):
                    lines[i] = indices
                    i += 1

    lines = lines.transpose()
    cols =[c.transpose() for c in lines]
    table = dict(zip(header, cols))
    return table
        
def to_plantgl(g, 
               leaf_material = None,
               stem_material = None,
               soil_material = None,
               colors = None,
               ambient_only = False):
    """
    Returns a plantgl scene from an mtg.
    """
    if colors is None:
        if leaf_material is None:
            leaf_material = Material(Color3(0,180,0))
        if stem_material is None:
            stem_material = Material(Color3(0,130,0))
        if soil_material is None:
            soil_material = Material(Color3(170, 85,0))
        colors = g.property('color')
        
    geometries = g.property('geometry')
    labels = g.property('can_label')
    scene = Scene()

    def geom2shape(vid, mesh, scene):
        shape = None
        if isinstance(mesh, list):
            for m in mesh:
                geom2shape(vid, m, scene)
            return
        if mesh is None:
            return
        if isinstance(mesh, Shape):
            shape = mesh
            mesh = mesh.geometry
        label = labels.get(vid)
        if colors:
            if ambient_only:
                shape = Shape(mesh, Material(ambient=Color3(* colors.get(vid, [0,0,0])), diffuse=0.0, specular=Color3(0,0,0)))
            else:
                shape = Shape(mesh, Material(Color3(* colors.get(vid, [0,0,0]) )))
        elif not label:
            if not shape:
                shape = Shape(mesh)
        elif label.is_soil():
            shape = Shape(mesh, soil_material)
        elif label.is_stem() and label.optical_id <= 1:
            shape = Shape(mesh, stem_material)
        elif label.is_stem() and label.optical_id > 1:
            shape = Shape(mesh, soil_material)
        elif label.is_leaf() and label.optical_id <= 1:
            shape = Shape(mesh, leaf_material)
        elif label.is_leaf() and label.optical_id > 1:
            shape = Shape(mesh, soil_material)
        shape.id = vid
        scene.add(shape)

    for vid, mesh in geometries.items():
        geom2shape(vid, mesh, scene)
    return scene,


def _line(ind, pts, label):
    s = "p 1 %s 3 %s"%(str(label), ' '.join('%.6f'%x for i in ind for x in pts[i]))
    return s

def to_canestra(g):
    """
    Return a string representing a canestra file.
    """
    geometry = g.property('geometry')
    can_label = g.property("can_label")

    begin = '# File generated by OpenAlea.Adel program'

    lines = [begin]
    max_scale = g.max_scale()

    for root_elt in g.roots_iter(scale=max_scale):
        for vid in pre_order(g, root_elt):
            mesh = geometry.get(vid)
            if not mesh:
                continue
            pts = numpy.array(mesh.pointList, ndmin=2)
            indices = numpy.array(mesh.indexList, ndmin=2)
            label = can_label[vid]
            lines.extend([_line(ind, pts, label) for ind in indices])
    lines.append('')
    return '\n'.join(lines)

def planter(g, distribution, random_seed=0, azimuths = None):
    """
    Transform a set of plants with given point distributions.

    :Parameters: 
        - g: MTG
        - distribution: a list of 2D positions
        - random_seed: add a random rotation to each plant if the value is positive.In this case, random_seed is used as a seed.
        - azimuth : a list defining plant azimuths (in radians). The list is recycled to achieve positioning of all the plants
    """
    #assert g.nb_vertices(scale=1) == len(distribution)
    geometry = g.property('geometry')
    
    # store the previous plant translation to not copy each time all the geometry.
    if '_plant_translation' not in g.properties():
        g.add_property('_plant_translation')
    translations = g.property('_plant_translation')
    

    if random_seed > 0:
        random.seed(random_seed)

    def pt2transfo(pt, previous_pt,rotation):
        matrix = Translation(pt).getMatrix()
        if rotation is not 0:
            r = AxisRotation((0,0,1), rotation).getMatrix()
            matrix = matrix * r * Translation(previous_pt).getMatrix()
        return Transform4(matrix), pt

    def transform_geom(geom, transfo, translation, rotation):
        if isinstance(geom, list):
            geom = [transform_geom(g,transfo, translation, rotation) for g in geom]
        elif isinstance(geom, Mesh):
            geom = geom.transform(transfo) if geom else geom
        elif isinstance(geom, Geometry):
            geom = Translated(translation, AxisRotated((0,0,1),rotation, geom))
        elif isinstance(geom, Shape):
            geom = Shape(Translated(translation, AxisRotated((0,0,1),rotation, geom.geometry)))
        return geom

    plants = g.vertices(scale=1)
    plants = plants[:len(distribution)]

    max_scale = g.max_scale()

    for i, root_elt in enumerate(plants):
        previous_translation = translations.get(root_elt,(0,0,0))
        translations[root_elt] = distribution[i]

        #displacement = Vector3(distribution[i])-Vector3(previous_translation)
        rotation = 0
        if azimuths is not None:
            rotation = azimuths[i]
        elif random_seed > 0:
            rotation = random.random()*pi
        
        transfo, translation = pt2transfo(Vector3(distribution[i]), -Vector3(previous_translation), rotation)
        l = (vid for vid in g.vertices_iter(scale=max_scale) if g.complex_at_scale(vid, scale=1) == root_elt) 
        #for vid in g.components_at_scale(root_elt, 4):
        for vid in l:
            geom = geometry.get(vid)
            geom = transform_geom(geom, transfo, translation, rotation)

            if geom:
                geometry[vid] = geom
                can_label = g.property('can_label').get(vid)
                if can_label:
                    can_label.plant_id = i

def duplicate(g, n=1):
    if g.nb_vertices(scale=1) == n:
        return g
    g1 = g.sub_mtg(g.root)
    for i in range(n-1):
        g1 = union(g1,g)
    return g1

class CanMTG(MTG):
    def __init__(self, functions, axial_string):
        MTG.__init__(self)
        symbols = {'newPlant' : 1, 'newAxe' : 2, 'newMetamer' :3, 'StemElement':4, 'LeafElement':4}
        g = read_lsystem_string(axial_string, symbols, functions, self)
        self.symbols = symbols


def apply_property(g, pname, function):
    """ Apply a function to each values of a MTG property.

    Returns this values as a dict (vid, new value).
    """
    prop = g.property(pname)
    return dict( (k, function(v)) for k, v in prop.items())

CanMTG.planter = planter
CanMTG.to_plantgl = to_plantgl
CanMTG.to_canestra = to_canestra
CanMTG.to_aggregation_table = to_aggregation_table

MTG.planter = planter
MTG.to_plantgl = to_plantgl
MTG.to_canestra = to_canestra
MTG.to_aggregation_table = to_aggregation_table

def convert(v, undef='NA'):
    res = v
    try:
        res = int(res)
    except ValueError:
        try:
            res = float(res)
        except ValueError:
            if res == undef:
                res = None
    return res

def properties(d, exclude = []):
    res = {}
    for k, v in d.items():
        if k in exclude:
            continue
        v = convert(v)
        if v is not None:
            res[k] = v
    return res

def properties_from_dict(d,index, exclude = []):
    res = {}
    for k in d:
        if k in exclude:
            continue
        res[k] = d[k][index]
    return res

def topological_table_to_mtg(csv_file, epsilon=1e-6):
    f = open(csv_file)
    l=f.readline()

    sniffer = csv.Sniffer()
    dialect = sniffer.sniff(l)
    # Go from start of file
    f.seek(0)

    reader = csv.DictReader(f, dialect=dialect)

    # Build the MTG
    g = MTG()
    topology = ['plant', 'axe', 'numphy']

    # buffers
    prev_plant = 0
    prev_axe = -1
    prev_metamer = -1
    vid_plant = -1
    vid_axe = -1
    vid_metamer = -1
    vid_node = -1

    # store the metamer vids of the axis 0 
    metamers = []
    nodes = []
    edge_type = '<'
    for d in reader:
        plant, axe, num_metamer = [int(convert(d.get(x),undef=None)) for x in topology]
        
        #print 'adding vertices for plant: %d, axe:%d, metamer: %d'%(plant, axe, num_metamer)
        # Add new plant
        if plant != prev_plant:
            label = 'plant'+str(plant)
            vid_plant = g.add_component(g.root, edge_type='/',label=label)
            vid_axe = -1
            vid_metamer = -1
            vid_node = -1
            prev_axe = -1
        #??
        if num_metamer < prev_metamer:
            prev_axe = -1
            prev_metamer = -1
            
        # Add an axis
        if axe != prev_axe:
            label = 'axe'+str(axe)
           
            
            if axe == 0:
                vid_axe = g.add_component(vid_plant,edge_type='/',label=label)
                vid_node = -1
            else:
                #args['edge_type'] = '+'
                edge_type = '+'
                vid_axe = g.add_child(vid_axe, edge_type=edge_type, label=label)
                #vid, vid_axe = g.add_child_and_complex(metamers[axe], complex=vid_axe, **args)

        # Add metamers
        args = properties(d, exclude=topology)

        assert num_metamer > 0
        label = 'metamer'+str(num_metamer)
        new_axe = True

        if axe==0 and num_metamer==1:
            metamers=[]
            edge_type = '/'
            vid_metamer = g.add_component(vid_axe, edge_type='/', label = label, **args)
        elif num_metamer == 1:
            # Add the first element connected to previous metamer on the previous axis
            edge_type = '+'
            vid_metamer, vid_axe =  g.add_child_and_complex(metamers[axe-1], complex=vid_axe, edge_type='+',label=label, **args)
            vid_node = nodes[axe-1]
        else:
            edge_type = '<'
            vid_metamer = g.add_child(vid_metamer, label=label, edge_type='<',**args)
            new_axe = False

        if axe == 0:
            metamers.append(vid_metamer)

        # Add internode, sheath, and lamina
        nb_internodes = 0
        nb_sheath = 0
        nb_leaf = 0

        # Internode
        if args['Ev'] > 0.:
            if args['Esen'] > args['Ev']:
                if vid_node == -1:
                    vid_node= g.add_component(vid_metamer, label='Esen', edge_type='/',length=args['Ev'],po=args['Epos'], diam=args['Ed'] )
                    assert edge_type == '/'
                else:
                    vid_node, vid_metamer= g.add_child_and_complex(vid_node, complex=vid_metamer, label='Esen', edge_type=edge_type,length=args['Ev'],po=args['Epos'], diam=args['Ed'] )
            else:
                if vid_node == -1:
                    vid_node= g.add_component(vid_metamer, label='Egreen', edge_type='/',length=args['Ev']-args['Esen'],po=args['Epo'], diam=args['Ed'] )
                    assert edge_type == '/'
                else:
                    vid_node, vid_metamer= g.add_child_and_complex(vid_node, complex=vid_metamer, label='Egreen', edge_type=edge_type,length=args['Ev']-args['Esen'],po=args['Epo'], diam=args['Ed'] )
                vid_node = g.add_child(vid_node, label='Esen', edge_type='<',length=args['Esen'],po=args['Epos'], diam=args['Ed'])
        else:
            if new_axe and args['Gv'] == 0.:
                if vid_node == -1:
                    vid_node= g.add_component(vid_metamer, label='Egreen', edge_type='/',length=0.,po=args['Epo'], diam=args['Ed'] )
                else:
                    vid_node, vid_metamer= g.add_child_and_complex(vid_node, complex=vid_metamer, label='Egreen', edge_type=edge_type,length=0.,po=args['Epo'], diam=args['Ed'] )
        # Sheath
        if args['Gv'] > 0.:
            if args['Gsen'] > args['Gv']:
                vid_node= g.add_child(vid_node, label='Gsen', edge_type='<',length=args['Gv'],po=args['Gpos'], diam=args['Gd'] )
            else:
                vid_node = g.add_child(vid_node, label='Ggreen', edge_type='<',length=args['Gv']-args['Gsen'],po=args['Gpo'], diam=args['Gd'] )
                vid_node = g.add_child(vid_node, label='Gsen', edge_type='<',length=args['Gsen'],po=args['Gpos'], diam=args['Gd'])

        if axe == 0:
            nodes.append(vid_node)

        # Laminae
        if args['Lv'] > 0.:
            if args['Lsen'] > args['Lv']:
                l_node= g.add_child(vid_node, label='Lsen', edge_type='+',length=args['Lv'],po=args['Lpos'],
                                      Ll=args['Ll'], Lw= args['Lw'], LcType=args['LcType'], LcIndex=args['LcIndex'], Linc=args['Linc'], Laz=args['Laz'],
                                      srb=0, srt=1)
            else:
                l_node = g.add_child(vid_node, label='Lgreen', edge_type='+',length=args['Lv']-args['Lsen'],po=args['Lpo'],
                                       Ll=args['Ll'], Lw= args['Lw'], LcType=args['LcType'], LcIndex=args['LcIndex'], Linc=args['Linc'], Laz=args['Laz'],
                                      srb=0, srt=1-(args['Lsen']/args['Lv']))
                l_node = g.add_child(l_node, label='Lsen', edge_type='<',length=args['Lsen'],po=args['Lpos'],
                                       Ll=args['Ll'], Lw= args['Lw'], LcType=args['LcType'], LcIndex=args['LcIndex'], Linc=args['Linc'], Laz=args['Laz'],
                                      srt=1, srb=1-(args['Lsen']/args['Lv']))

        
        prev_plant = plant
        prev_axe = axe
        prev_metamer = num_metamer

        


    f.close()

    return fat_mtg(g)

def internode(g, vid_axe, vid_metamer, prev_node, props, epsilon):
    if props['Ev'] < epsilon:
        return prev_node

def mtg_factory(params, sectors = 1):
    """ Construct a MTG from a dictionary.

    The dictionary contains the parameters and a list of elements. Sector is an integer giving the number of LeafElements per Leaf
    The keys of params are:
        - plant: indx of plant
        - axe: 
        - numphy
        - Lv
        - L_shape
        - Lsen
        - Lw_shape
        - LcType
        - LcIndex
        - Linc
        - Laz
        - Lpo
        - Lpos
        - Gl
        - Gv
        - Gsen
        - Gpo
        - Gpos
        - Gd
        - Ginc
        - El
        - Ev
        - Esen
        - Ed
        - Einc
        - Epo
        - Epos

    :TODO: 
        * add length and final_length (DONE)
        * fix naming convention for Linc: relative inclination (DONE)
        * Add a scale to define the tissue types (ear, sheath, laminae, gain)
        * diam and final_diam (resp. width)
        * function reset length
        * function phenology(g, table) -> dynamic parameters (start_thermaltime, end_thermaltime)
        * function growthThermaltime(g, tt, dtt): tt=thermaltime du couvert
        * function growthThermaltime(g, tt, dtt, stress factor)
        * stress factor: offre/demande
            - demand = :math:`D=\int_{tt}^{tt+dtt}{S(x)dx}*\rho_s+\int_{tt}^{tt+dtt}{V(x)dx}*\rho_v`
            - offre : :math:`sum{E_abs}*\eps_b`
            => ds = ds_predit* stress_factor
        * give the area to the leaf model
        * update properties
    """

    if not _check_adel_parameters(params):
        raise ValueError('Adel parameters are invalid')

    g = MTG()
    topology = ['plant', 'axe', 'numphy']

    # buffers
    prev_plant = 0
    prev_axe = -1
    prev_metamer = -1
    vid_plant = -1
    vid_axe = -1
    vid_metamer = -1
    vid_node = -1

    # store the metamer vids of the axis 0 
    metamers = []
    nodes = []
    edge_type = '<'

    dp = params
    nrow = len(params['plant'])
    for i in range(nrow):

        #plant, axe, num_metamer = [int(convert(d.get(x),undef=None)) for x in topology]
        plant = int(dp['plant'][i])
        try:
            axe = int(dp['axe'][i])
        except:
            axe = int(dp['ms_insertion'][i])
        num_metamer = int(dp['numphy'][i])

        #plant, axe, num_metamer = [int(convert(d.get(x),undef=None)) for x in topology]
        #print 'plant: %d, axe:%d, nb_metamers: %d'%(plant, axe, num_metamer)
        # Add new plant
        if plant != prev_plant:
            label = 'plant'+str(plant)
            vid_plant = g.add_component(g.root, label=label, edge_type='/')
            vid_axe = -1
            vid_metamer = -1
            vid_node = -1
            prev_axe = -1

        if num_metamer < prev_metamer:
            prev_axe = -1
            prev_metamer = -1
            
        # Add an axis
        if axe != prev_axe:
            label = 'axe'+str(axe)
           
            
            if axe == 0:
                vid_axe = g.add_component(vid_plant,edge_type='/',label=label)
                vid_node = -1
            else:
                #args['edge_type'] = '+'
                edge_type = '+'
                assert g.parent(vid_plant) is None
                new_axe = g.add_child(vid_axe,edge_type=edge_type,label=label)
                print(vid_axe, new_axe, vid_plant)
                assert g.parent(vid_plant) is None
                #vid, vid_axe = g.add_child_and_complex(metamers[axe], complex=vid_axe, **args)

        # Add metamers
        args = properties_from_dict(dp,i,exclude=topology)

        assert num_metamer > 0
        label = 'metamer'+str(num_metamer)

        if axe==0 and num_metamer==1:
            metamers=[]
            edge_type = '/'
            vid_metamer = g.add_component(vid_axe, edge_type='/', label = label, **args)
        elif num_metamer == 1:
            # Add the first element connected to previous metamer on the previous axis
            edge_type = '+'
            vid_metamer = g.add_component(vid_axe, label=label, **args)
            vid_metamer =  g.add_child(metamers[axe-1], child=vid_metamer, edge_type='+')
            vid_node = nodes[axe-1]
        else:
            edge_type = '<'
            vid_metamer = g.add_child(vid_metamer, label=label, edge_type='<',**args)

        if axe == 0:
            metamers.append(vid_metamer)

        # Add internode, sheath, and lamina

        # Visible Internode
        #if args['Ev'] > 0.:
        tissue = 'internode'

        # Several cases:
        Egreen = args['Ev']-args['Esen'] if args['Ev']-args['Esen'] >0. else 0.
        Esen = args['Ev'] if Egreen == 0. else args['Esen']

        #  - Green element and perhaps a senescent one
        if vid_node == -1:
            # first metamer on the axis
            vid_node= g.add_component(vid_metamer, label='StemElement', edge_type='/',
                length=Egreen,final_length=args['El'],po=args['Epo'], diam=args['Ed'], tissue=tissue, inclination=args['Einc'] )
            assert edge_type == '/'
        else:
            # first element on the metamer which has a parent metamer on the axis
            new_node = g.add_component(vid_metamer)
            vid_node= g.add_child(vid_node,child=new_node, 
                    label='StemElement', edge_type=edge_type,
                    length=Egreen,final_length=args['El'],po=args['Epo'], diam=args['Ed'], tissue=tissue, inclination=args['Einc'] )
        # Add a senescent element
        #if args['Esen'] > 0.:
        vid_node = g.add_child(vid_node, label='StemElement', edge_type='<',
            length=Esen,final_length=args['El'],po=args['Epos'], diam=args['Ed'], tissue=tissue, sen=True, inclination=0.)


        # Sheath
        # Same logic that described previously.
        Ggreen = args['Gv']-args['Gsen'] if args['Gv']-args['Gsen'] >0. else 0.
        Gsen = args['Gv'] if Ggreen == 0. else args['Gsen']
    
        vid_node= g.add_child(vid_node, label='StemElement', edge_type='<',
        length=Ggreen,final_length=args['Gl'],po=args['Gpo'], diam=args['Gd'], tissue=tissue, inclination=args['Ginc'] )
        #if args['Gsen'] > 0.:
        vid_node= g.add_child(vid_node, label='StemElement', edge_type='<',
        length=Gsen,final_length=args['Gl'],po=args['Gpos'], diam=args['Gd'], sen=True, tissue=tissue, inclination=0.)

        if axe == 0:
            nodes.append(vid_node)

        # Lamina
        #if args['Lv'] > 0.:
        l_node = vid_node
        tissue='lamina'
        ds = 1. / sectors
        srlim = 1.-(args['Lsen']/args['Lv'])
        st = ds
        edge_type = '+'
        Laz = args['Laz']

        Lgreen = args['Lv']-args['Lsen'] if args['Lv']-args['Lsen'] >0. else 0.
        Lsen = args['Lv'] if Lgreen == 0. else args['Lsen']
        for isect in range(sectors):
            # create one green and/or one senescent sector
            srb_green = st-ds
            srt_green = min(st, max(srb_green,srlim))
            srb_sen = srt_green
            srt_sen= st

            l_node = g.add_child(l_node, label='LeafElement', edge_type=edge_type,
                                 length=args['Lv'],final_length=args['L_shape'],po=args['Lpo'],
                                 Ll=args['Ll'], Lw= args['Lw_shape'], LcType=args['LcType'], 
                                 LcIndex=args['LcIndex'], Laz=Laz,Linc=args['Linc'], 
                                 srb=srb_green, srt=srt_green, tissue=tissue)

            l_node = g.add_child(l_node, label='LeafElement', edge_type='<',
                                 length=args['Lv'],final_length=args['L_shape'],po=args['Lpos'],
                                 Ll=args['Ll'], Lw= args['Lw_shape'], LcType=args['LcType'], 
                                 LcIndex=args['LcIndex'], Laz=Laz,Linc=args['Linc'], 
                                 srb=srb_sen, srt=srt_sen, sen=True, tissue=tissue)
            st += ds
            edge_type = '<'

        
        prev_plant = plant
        prev_axe = axe
        prev_metamer = num_metamer

    
    return fat_mtg(g)


def _check_adel_parameters(params):
    return True

def compute_element(n, symbols):
    leaf = symbols.get('LeafElement')
    stem = symbols.get('StemElement')

    leaf_rank = int(n.complex().index())
    optical_species = int(n.po)
    final_length = n.final_length
    length = n.length
    s_base = n.srb
    s_top = n.srt
    seed = n.LcIndex
    #leaf inclination
    linc = n.Linc
    
    element = {} 
    if n.label.startswith('L'):
        radius_max = n.Lw
        element = leaf(optical_species, 
                    final_length, 
                    length, 
                    radius_max, 
                    s_base, 
                    s_top, 
                    leaf_rank,
                    seed,
                    linc) 
    else:
        diameter_base = n.parent().diam if (n.parent() and n.parent().diam > 0.) else n.diam
        diameter_top = n.diam
        element = stem( optical_species, length, diameter_base, diameter_top)

    can_label =  element.get('label')
    if can_label:
        can_label.elt_id = leaf_rank
        plant_node = n.complex_at_scale(scale=1)
        can_label.plant_id = plant_node.index()
        
    geom = element.get('geometry')
    
    return geom, can_label

def transform(turtle, mesh):
        x = turtle.getUp()
        z = turtle.getHeading()

        bo = BaseOrientation(x, z^x)
        matrix = Transform4(bo.getMatrix())
        matrix.translate(turtle.getPosition())
        #print 'Position ', turtle.getPosition()
        mesh = mesh.transform(matrix)
        return mesh



def mtg_turtle(g, symbols):
    ''' Compute the geometry on each node of the MTG using Turtle geometry. '''

    from openalea.mtg import turtle

    plants = g.component_roots_at_scale_iter(g.root, scale=1)
    nplants = g.nb_vertices(scale=1)

    gt = MTG()

    def adel_visitor(g, v, turtle):
        # 1. retriev the node
        n = g.node(v)
        angle = float(n.Laz) if n.Laz else 0.
        turtle.rollL(angle)
        if g.edge_type(v) == '+':
            if not n.label.startswith('L'):
                angle = n.Ginc or n.Einc
                angle = float(angle) if angle is not None else 0.
                turtle.up(angle)

        # 2. Compute the geometric symbol
        mesh, can_label = compute_element(n, symbols)
        if mesh:
            n.geometry = transform(turtle, mesh)
            n.can_label = can_label

        # 3. Update the turtle
        turtle.setId(v)
        if n.label.startswith('S'):
            turtle.f(n.length)
        # Get the azimuth angle

    for plant in plants:
       gplant = g.sub_mtg(plant)
       scene = turtle.TurtleFrame(gplant,visitor=adel_visitor)
       gt = union(gplant,gt)
       
    return gt
    

def mtg_turtle_time(g, symbols, time, update_visitor=None ):
    ''' Compute the geometry on each node of the MTG using Turtle geometry. 
    
    Update_visitor is a function called on each node in a pre order (parent before children).
    This function allow to update the parameters and state variables of the vertices.
    
    :Example:

        >>> def grow(node, time):
                
    '''

    g.properties()['geometry'] = {}
    g.properties()['_plant_translation'] = {}

    max_scale = g.max_scale()

    def compute_element(n, symbols, time):
        leaf = symbols.get('LeafElement')
        stem = symbols.get('StemElement')

        leaf_rank = int(n.complex().index())
        optical_species = int(n.po)

        metamer = n.complex()

        # Length computation
        if update_visitor:
            length = n.length
            final_length = metamer.final_length
        else:
            final_length = n.final_length
            try :
                length = final_length * (time - metamer.start_tt) / (metamer.end_tt - metamer.start_tt) if metamer.end_tt and time < metamer.end_tt else n.length
            except:
                length = n.length

        if update_visitor and  n.label.startswith('L'):
            if metamer.final_length is None:
                metamer.final_length = n.final_length
                metamer.length = n.length
            length = metamer.length
            prev_length = metamer.final_length * (n.start_tt - metamer.start_tt) / (metamer.end_tt -metamer.start_tt)
            s_base = (metamer.length - prev_length - n.length) / metamer.length
        else:
            s_base = n.srb
        s_top = n.srt
        seed = n.LcIndex
        #leaf inclination

        if update_visitor and  n.label.startswith('L'):
            linc = metamer.insertion_angle
        else:
            linc = n.Linc
 
        element = {} 
        if n.label.startswith('L'):
            radius_max = n.Lw
            element = leaf(optical_species, 
                        final_length, 
                        length, 
                        radius_max, 
                        s_base, 
                        s_top, 
                        leaf_rank, seed, linc) 
        else:
            diameter_base = n.parent().diam if (n.parent() and n.parent().diam > 0.) else n.diam
            diameter_top = n.diam
            element = stem( optical_species, length, diameter_base, diameter_top)

        can_label =  element.get('label')
        if can_label:
            can_label.elt_id = leaf_rank
            plant_node = n.complex_at_scale(scale=1)
            can_label.plant_id = plant_node.index()
            
        geom = element.get('geometry')
        
        return geom, can_label

    def adel_visitor(g, v, turtle, time):
        # 1. retriev the node

        n = g.node(v)

        # Update visitor to compute or modified the node parameters
        if update_visitor is not None:
            update_visitor(n, time)

            if 'Leaf' in n.label:
                metamer = n.complex()
                if (n.start_tt <= time < n.end_tt) or ((time >= metamer.end_tt) and n.edge_type()=='+'):
                    angle = float(metamer.Laz) if metamer.Laz else 0.
                    turtle.rollL(angle)
        else:
            if 'Leaf' in n.label:
                if n.edge_type()=='+':
                    angle = float(n.Laz) if n.Laz else 0.
                    turtle.rollL(angle)
            else:
                angle = float(n.Laz) if n.Laz else 0.
                turtle.rollL(angle)
        
        if g.edge_type(v) == '+':
            angle = n.Ginc or n.Einc
            angle = float(angle) if angle is not None else 0.
            #angle = n.inclination
            #angle = float(angle) if angle is not None else 0.
            turtle.up(angle)

        # 2. Compute the geometric symbol
        mesh, can_label = compute_element(n, symbols, time)
        if mesh:
            n.geometry = transform(turtle, mesh)
            n.can_label = can_label

        # 3. Update the turtle
        turtle.setId(v)

        m = n.complex()
        if update_visitor:
            length = n.length
        else:
            try:
                length = n.length * (time - m.start_tt) / (m.end_tt - m.start_tt) if time < m.end_tt else n.length
            except:
                length = n.length
        if ('Leaf' not in n.label) and (length > 0.):
            turtle.F(length)
        # Get the azimuth angle
        

    def traverse_with_turtle_time(g, vid, time, visitor=adel_visitor):
        turtle = PglTurtle()
        def push_turtle(v):
            n = g.node(v)
            #if 'Leaf' in n.label:
                #    return False
            try:
                start_tt = n.complex().start_tt
                if start_tt > time:
                    return False
            except: 
                pass
            if g.edge_type(v) == '+':
                turtle.push()
            return True

        def pop_turtle(v):
            n = g.node(v)
            try:
                start_tt = n.complex().start_tt
                if start_tt > time:
                    return False
            except: 
                pass
            if g.edge_type(v) == '+':
                turtle.pop()

        if g.node(vid).complex().start_tt <= time:
            visitor(g,vid,turtle,time)
            #turtle.push()
        plant_id = g.complex_at_scale(vid, scale=1)
        for v in pre_order2_with_filter(g, vid, None, push_turtle, pop_turtle):
            if v == vid: continue
            # Done for the leaves
            if g.node(v).complex().start_tt > time:
                print('Do not consider ', v, time)
                continue
            visitor(g,v,turtle,time)

        scene = turtle.getScene()
        return g

    for plant_id in g.component_roots_at_scale_iter(g.root, scale=max_scale):
        g = traverse_with_turtle_time(g, plant_id, time)
    return g

def thermal_time(g, phyllochron=110., leaf_duration=1.6, stem_duration=1.6, leaf_falling_rate = 10):
    """
    Add dynamic properties on the mtg to simulate developpement
    leaf_duration is the phyllochronic time for a leaf to develop from tip appearance to collar appearance
    stem_duration is the phyllochronic time for a stem to develop
    falling_rate (degrees / phyllochron) is the rate at which leaves fall after colar appearance
    """

    plants = g.vertices(scale=1)
    metamer_scale = g.max_scale()-1

    for plant in plants:
        tt = 0
        v = g.component_roots_at_scale_iter(plant, scale=metamer_scale).next()
        for metamer in pre_order2(g, v):
            end_leaf = tt + phyllochron*leaf_duration
            nm = g.node(metamer)
            nm.start_tt = tt
            nm.end_tt = end_leaf
            nm.frate = leaf_falling_rate / phyllochron
            sectors = [node for node in nm.components() if 'Leaf' in node.label]
            stems = [node for node in nm.components() if 'Stem' in node.label]
            
            nb_stems = len(stems)
            stem_tt = end_leaf
            dtt = phyllochron*stem_duration / nb_stems
            for stem in stems:
                stem.start_tt = stem_tt
                stem.end_tt = stem_tt+dtt
                stem_tt += dtt

            nb_sectors = max(1,len(sectors))
            sector_tt = end_leaf
            dtt = phyllochron*leaf_duration/nb_sectors 
            for sector in sectors:
                sector.start_tt = sector_tt - dtt
                sector.end_tt = sector_tt
                sector_tt -= dtt

            tt += phyllochron

    return g


